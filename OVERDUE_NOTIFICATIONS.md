# Функциональность уведомлений о просроченных книгах

## Обзор

Реализована полная функциональность автоматических уведомлений о просроченных книгах в системе LibraryLending, которая включает:

- ✅ Автоматическое обнаружение просроченных займов
- ✅ Создание и отправка уведомлений читателям
- ✅ Механизм повторных попыток при сбоях
- ✅ Предотвращение дублирования уведомлений
- ✅ Фоновая обработка с автоматическим восстановлением после перезапуска

## Архитектура решения

### Новые сущности

1. **OverdueNotification** - основная сущность для управления уведомлениями
   - Связана с конкретным займом (Loan) и читателем (Patron)
   - Отслеживает статус отправки (Pending, Sent, Failed)
   - Ведет счетчик попыток отправки
   - Сохраняет информацию об ошибках

2. **NotificationStatus** - enum для статусов уведомлений
   - `Pending` - ожидает отправки
   - `Sent` - успешно отправлено
   - `Failed` - ошибка отправки

### Новые репозитории и сервисы

1. **IOverdueNotificationRepository** - репозиторий для работы с уведомлениями
2. **INotificationService** - сервис для отправки уведомлений (email)
3. **OverdueNotificationBackgroundService** - фоновый сервис для автоматической обработки

### Use Cases

**ProcessOverdueNotificationsCommandHandler** - основной обработчик который:
- Находит все просроченные займы без уведомлений
- Создает новые уведомления
- Отправляет pending уведомления
- Повторяет неудачные попытки отправки

## Бизнес-правила

### Определение просроченных займов
- Займ считается просроченным, если текущая дата > DueAt и книга не возвращена
- Срок займа составляет 14 дней с даты выдачи

### Логика уведомлений
- Одно уведомление создается для каждого просроченного займа
- Уведомления не дублируются - проверяется существование по LoanId
- При временном сбое уведомление помечается как Failed и будет повторено позже
- Максимум 5 попыток отправки для каждого уведомления

### Фоновая обработка
- Автоматическая проверка каждый час
- Устойчивость к перезапускам сервиса
- Логирование всех операций для мониторинга

## API

### POST /api/notifications/process-overdue
Ручной запуск обработки просроченных уведомлений

**Ответ:**
```json
{
  "message": "Overdue notifications processed successfully",
  "processedCount": 5,
  "sentCount": 4,
  "failedCount": 1
}
```

## Тестирование

Реализованы три уровня тестов:

### 1. Unit тесты
- `ProcessOverdueNotificationsCommandHandlerTests` - тестирование основной логики
- Проверка создания уведомлений, отправки, обработки ошибок

### 2. Интеграционные тесты
- `OverdueNotificationIntegrationTests` - тестирование репозитория с базой данных
- Проверка CRUD операций, фильтрации, предотвращения дубликатов

### 3. End-to-End тесты
- `OverdueNotificationEndToEndTests` - полный сценарий работы
- Тестирование сценариев успеха, сбоев и восстановления

## Сценарии использования (выполнены)

### ✅ Сценарий 1: Успешное уведомление
- **Дано:** у читателя есть выдача, срок возврата которой прошёл вчера
- **Когда:** наступает ежедневная проверка
- **Тогда:** система отправляет читателю уведомление и сохраняет запись об этом

### ✅ Сценарий 2: Временный сбой доставки
- **Дано:** у читателя есть просроченная выдача, но почтовый сервис временно недоступен
- **Когда:** система пытается отправить уведомление
- **Тогда:** уведомление сохраняется как "ожидает повторной отправки" и будет доставлено при следующей попытке

### ✅ Сценарий 3: Отсутствие дублей
- **Дано:** у читателя есть просроченная выдача
- **Когда:** система несколько раз подряд запускает проверку
- **Тогда:** читатель всё равно получает только одно уведомление об этой выдаче

### ✅ Сценарий 4: Устойчивость к перезапуску
- **Дано:** есть непросланные уведомления в очереди
- **Когда:** сервис перезапускается
- **Тогда:** после восстановления система продолжает рассылку и доводит все уведомления до конца

## База данных

Добавлена новая таблица `overdue_notifications`:

```sql
CREATE TABLE overdue_notifications (
    id uniqueidentifier PRIMARY KEY,
    loan_id uniqueidentifier NOT NULL UNIQUE,
    patron_id uniqueidentifier NOT NULL,
    status int NOT NULL,
    created_at datetime2 NOT NULL,
    sent_at datetime2 NULL,
    retry_count int NOT NULL,
    error_message nvarchar(1000) NULL,
    
    FOREIGN KEY (loan_id) REFERENCES loans(id),
    FOREIGN KEY (patron_id) REFERENCES patrons(id)
);
```

## Мониторинг и логирование

Все операции логируются на соответствующих уровнях:
- INFO - успешные операции
- WARNING - неудачные попытки отправки
- ERROR - критические ошибки

## Настройка и развертывание

1. Функциональность автоматически активируется при запуске приложения
2. Фоновый сервис запускается автоматически
3. Интервал проверки: 1 час (настраивается в коде)
4. При ошибках повторная попытка через 5 минут

## Будущие улучшения

- Конфигурируемые интервалы проверки
- Различные типы уведомлений (SMS, push)
- Dashboard для мониторинга уведомлений
- Настройка шаблонов писем
- Более сложная логика повторных попыток (exponential backoff)
